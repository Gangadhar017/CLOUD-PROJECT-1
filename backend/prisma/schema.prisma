generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  username      String    @unique
  email         String    @unique
  passwordHash  String    @map("password_hash")
  role          UserRole  @default(USER)
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLoginAt   DateTime? @map("last_login_at")

  submissions   Submission[]
  registrations ContestRegistration[]
  refreshTokens RefreshToken[]
  auditLogs     AuditLog[]

  @@index([username])
  @@index([email])
  @@map("users")
}

model RefreshToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  token     String    @unique
  expiresAt DateTime  @map("expires_at")
  createdAt DateTime  @default(now()) @map("created_at")
  revokedAt DateTime? @map("revoked_at")
  ipAddress String?   @map("ip_address")
  userAgent String?   @map("user_agent")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("refresh_tokens")
}

model Contest {
  id           String        @id @default(uuid())
  name         String
  description  String
  startTime    DateTime      @map("start_time")
  endTime      DateTime      @map("end_time")
  freezeTime   DateTime?     @map("freeze_time")
  isPublic     Boolean       @default(true) @map("is_public")
  status       ContestStatus @default(UPCOMING)
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  createdBy    String        @map("created_by")

  problems      Problem[]
  submissions   Submission[]
  registrations ContestRegistration[]
  snapshots     LeaderboardSnapshot[]

  @@index([status])
  @@index([startTime])
  @@index([endTime])
  @@map("contests")
}

model Problem {
  id          String   @id @default(uuid())
  contestId   String   @map("contest_id")
  title       String
  description String
  difficulty  Difficulty
  points      Int
  timeLimit   Int      @default(1000) @map("time_limit")
  memoryLimit Int      @default(256) @map("memory_limit")
  order       Int      @default(0)
  createdAt   DateTime @default(now()) @map("created_at")

  contest      Contest       @relation(fields: [contestId], references: [id], onDelete: Cascade)
  testCases    TestCase[]
  submissions  Submission[]

  @@index([contestId])
  @@index([order])
  @@map("problems")
}

model TestCase {
  id        String @id @default(uuid())
  problemId String @map("problem_id")
  input     String
  output    String
  isSample  Boolean @default(false) @map("is_sample")
  order     Int    @default(0)

  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@index([problemId])
  @@map("test_cases")
}

model Submission {
  id                String          @id @default(uuid())
  contestId         String          @map("contest_id")
  problemId         String          @map("problem_id")
  userId            String          @map("user_id")
  language          String
  code              String
  codeHash          String          @map("code_hash")
  verdict           Verdict         @default(PENDING)
  score             Int             @default(0)
  executionTime     Int?            @map("execution_time")
  memoryUsed        Int?            @map("memory_used")
  testCasesPassed   Int             @default(0) @map("test_cases_passed")
  totalTestCases    Int             @default(0) @map("total_test_cases")
  idempotencyKey    String          @unique @map("idempotency_key")
  runnerId          String?         @map("runner_id")
  runnerSignature   String?         @map("runner_signature")
  submittedAt       DateTime        @default(now()) @map("submitted_at")
  startedAt         DateTime?       @map("started_at")
  completedAt       DateTime?       @map("completed_at")

  contest         Contest           @relation(fields: [contestId], references: [id], onDelete: Cascade)
  problem         Problem           @relation(fields: [problemId], references: [id], onDelete: Cascade)
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  verdictHistory  VerdictHistory[]

  @@index([contestId])
  @@index([problemId])
  @@index([userId])
  @@index([verdict])
  @@index([submittedAt])
  @@index([idempotencyKey])
  @@map("submissions")
}

model VerdictHistory {
  id           String    @id @default(uuid())
  submissionId String    @map("submission_id")
  oldVerdict   Verdict   @map("old_verdict")
  newVerdict   Verdict   @map("new_verdict")
  changedAt    DateTime  @default(now()) @map("changed_at")
  changedBy    String?   @map("changed_by")
  reason       String?

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@index([submissionId])
  @@index([changedAt])
  @@map("verdict_history")
}

model ContestRegistration {
  id        String   @id @default(uuid())
  contestId String   @map("contest_id")
  userId    String   @map("user_id")
  registeredAt DateTime @default(now()) @map("registered_at")
  ipAddress String?  @map("ip_address")

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([contestId, userId])
  @@index([contestId])
  @@index([userId])
  @@map("contest_registrations")
}

model LeaderboardSnapshot {
  id        String   @id @default(uuid())
  contestId String   @map("contest_id")
  data      String
  isFinal   Boolean  @default(false) @map("is_final")
  createdAt DateTime @default(now()) @map("created_at")

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)

  @@index([contestId])
  @@index([isFinal])
  @@map("leaderboard_snapshots")
}

model AuditLog {
  id          String   @id @default(uuid())
  userId      String?  @map("user_id")
  action      String
  entityType  String   @map("entity_type")
  entityId    String?  @map("entity_id")
  oldValue    String?  @map("old_value")
  newValue    String?  @map("new_value")
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  createdAt   DateTime @default(now()) @map("created_at")

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model Runner {
  id           String    @id @default(uuid())
  name         String
  publicKey    String    @unique @map("public_key")
  isActive     Boolean   @default(true) @map("is_active")
  lastSeenAt   DateTime? @map("last_seen_at")
  createdAt    DateTime  @default(now()) @map("created_at")
  ipAddress    String?   @map("ip_address")

  @@index([publicKey])
  @@index([isActive])
  @@map("runners")
}

model RateLimit {
  id        String   @id @default(uuid())
  key       String   @unique
  count     Int      @default(0)
  windowStart DateTime @default(now()) @map("window_start")
  expiresAt DateTime @map("expires_at")

  @@index([key])
  @@index([expiresAt])
  @@map("rate_limits")
}

enum UserRole {
  USER
  ADMIN
  CONTESTANT
}

enum ContestStatus {
  UPCOMING
  RUNNING
  FROZEN
  ENDED
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum Verdict {
  PENDING
  COMPILING
  RUNNING
  ACCEPTED
  WRONG_ANSWER
  TIME_LIMIT_EXCEEDED
  MEMORY_LIMIT_EXCEEDED
  RUNTIME_ERROR
  COMPILATION_ERROR
  SYSTEM_ERROR
  VERIFYING
}
